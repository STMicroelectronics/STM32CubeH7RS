<!DOCTYPE html>
<html>

  <head>
    <title>Projects Overview</title>
    <style>
      .descriptionColumn { min-width:550px;}
      em{color:red;font-weight: bold;}
      importantLink {font-size:10pt; font-family: "Verdana","sans-serif" color:black;}
      article{border: 1px solid #828282;margin: 20px 0px 20px 9px;}
      body{font-family: Verdana;font-size: 10pt; color: black;margin-left: 40px;}
      .picture{text-align: center}
      .copyright{text-align: center}
      h1{text-align: center;font-size: 20pt; font-family: Verdana; color: rgb(51, 102, 255);}
    </style>
  </head>
  <body>

    <h1>STM32CubeH7RS Firmware Examples for STM32H7RSxx Series</h1>

    <p class="copyright">Copyright 2024 STMicroelectronics</p>

    <div class="picture">
      <img alt="" id="_x0000_i1025" src="../_htmresc/st_logo_2020.png" style="border: 0px solid ; width: 104px; height: 77px;"/>
    </div>

    <p>The STM32CubeH7RS Firmware package comes with a rich set of examples running on STMicroelectronics boards, organized by board and provided with preconfigured projects for the main supported toolchains.</p>

    <div class="picture">
      <img alt="" src="../_htmresc/STM32Cube_2020.bmp"/>
    </div>

    <p>The examples are classified depending on the STM32Cube level they apply to, and are named as follows:</p>

    <ul>
      <li id="Examples"><b>Examples</b> uses only the HAL and BSP drivers (Middleware not used), having as objective to demonstrate the product/peripherals features and usage. The examples are organized per peripheral (a folder for each peripheral, ex. TIM) and offers different complexity level from basic usage of a given peripheral (ex. PWM generation using timer) till integration of several peripherals(use DAC for signals generation with synchronization from TIM6 and DMA). Board resources usage is reduced to the strict minimum.</li>
      <li id="Examples_LL"><b>Examples_LL</b> uses only the LL drivers (HAL and Middleware not used), offering optimum implementation of typical use cases of the peripheral features and configuration procedures. The examples are organized per peripheral (a folder for each peripheral, ex. TIM) and runs exclusively on Nucleo board.</li>
      <li id="Examples_MIX"><b>Examples_MIX</b> uses only HAL, BSP and LL drivers (Middleware are not used), having as objective to demonstrate how to use both HAL and LL APIs in the same application, to combine the advantages of both APIs (HAL offers high level and functionalities oriented APIs, with high portability level and hide product or IPs complexity to end user. While LL offers low level APIs at registers level with better optimization). The examples are organized per peripheral (a folder for each peripheral, ex. TIM) and runs exclusively on Nucleo board.</li>
      <li id="Applications"><b>Applications</b> intends to demonstrate the product performance and how to use the different Middleware stacks available. The Applications are organized per Middleware (a folder for each Middleware, ex. USB Host) or product feature that need high level firmware bricks (ex. Audio). Integration Applications that use several Middleware stacks are provided as well.</li>
      <li><b>Templates</b> projects are provided to allow user to quickly build any firmware application on a given board.</li>
      <li><b>Templates_Board</b> project provides a reference template for the NUCLEO-H7S3L8 board based on HAL and BSP drivers that can be used to build any firmware application to execute from external Flash (Sub-project Appli).It boots from internal Flash and jumps to the application code in external Flash (Sub-project Boot).
             It was created from STM32CubeMX using the "Start My project from ST board" feature</li>
    </ul>

    <p>The examples are located under STM32Cube_FW_H7RS_VX.Y.Z\Projects\, and all of them have the same structure:</p>

    <ul>
      <li>
        <b>Boot</b>
      </li>
      <ul>
        <li>\Inc folder that contains all header files for Boot part.</li>
        <li>\Src folder for the sources code for Boot part.</li>
      </ul>
      <li>
        <b>Appli</b>
      </li>
      <ul>
        <li>\Inc folder that contains all header files for Appli part.</li>
        <li>\Src folder for the sources code for Appli part.</li>
      </ul>
      <li>\EWARM, \MDK-ARM and \STM32CubeIDE folders contain the preconfigured project for each toolchain.</li>
      <li>A readme describing the example behavior and the environment required to run the example.</li>
    </ul>

    <p>To run the example, you have to do the following:</p>

    <ul>
      <li>Open the example using your preferred toolchain.</li>
      <li>Rebuild all files and load the image into target memory.</li>
      <li>Run the example by following the readme instructions.</li>
      <li>
        <i><u>Note</u>: refer to section "Development Toolchains and Compilers" and "Supported Devices and EVAL, Nucleo and Discovery boards" of the Firmware package release notes to know about the SW/HW environment used for the Firmware development and validation. The correct operation of the provided examples is not guaranteed on some environments, for example when using different compiler or board versions.</i>
      </li>
    </ul>

    <p>The provided examples can be tailored to run on any compatible hardware; user simply need to update the BSP drivers for his board, if it has the same hardware functions (LED, LCD display, pushbuttons...etc.). The BSP is based on a modular architecture that allows it to be ported easily to any hardware by just implementing the low level routines.</p>

    <p>
      <div>The table below contains the list of examples provided within STM32Cube_FW_H7RS Firmware package.</div>
      <div>In this table, the label <b>CubeMX</b> means the projects have been created using <a href="https://www.st.com/en/development-tools/stm32cubemx.html" target="_blank">STM32CubeMX</a>, the STM32Cube initialization code generator. Those projects can be opened with this tools to modify the projects itself. The others projects are manually created to demonstrate the product features.</div>
    </p>

    <p id="STM32H7RSxxImportantLink">
      <div>Reference materials available on <a href="http://www.st.com/stm32cubefw" target="_blank">www.st.com/stm32cubefw</a></div>
      <ul>
        <li><a href="http://www.st.com/stm32cubefw" target="_blank">Latest release</a> of STM32CubeH7RS Firmware package.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM01040137.pdf" target="_blank">UM3294</a>: Getting started with STM32CubeH7RS for STM32H7Rx/Sx MCUs.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM01054249.pdf" target="_blank">UM3309</a>: Description of STM32H7Rx/Sx HAL and LL drivers.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00108129.pdf" target="_blank">UM1734</a>: STM32Cube USB Device library.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00105256.pdf" target="_blank">UM1720</a>: STM32Cube USB host library.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00105259.pdf" target="_blank">UM1721</a>: Developing Applications on STM32Cube with FatFs.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00105262.pdf" target="_blank">UM1722</a>: Developing Applications on STM32Cube with RTOS.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00103685.pdf" target="_blank">UM1713</a>: Developing applications on STM32Cube with LwIP TCP/IP stack.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00103145.pdf" target="_blank">UM1709</a>: STM32Cube Ethernet IAP example.</li>
      </ul>
    </p>
		<table border='1' bgcolor='#f0f0fF' >
			<tr align=center style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;">
				<td><b>Level</b></td>
				<td><b>Module Name</b></td>
				<td><b>Project Name</b></td>
				<td class="descriptionColumn"><b>Description</b></td>
				<td>STM32H7S78-DK</td>
				<td>STM32H7RS_CUSTOM_HW</td>
				<td>NUCLEO-H7S3L8</td>
			</tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=6><p id="Templates">Templates</p></td>
        <td align=left rowspan=3><p id="-">-</p></td>
        <td align=left><p id="Template">Template</p></td>
        <td align=left>
- This project provides a reference template based on the STM32Cube HAL API that can be used
to build any firmware application to execute from internal Flash.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="Template_LRUN">Template_LRUN</p></td>
        <td align=left>
- This project provides a reference template based on the STM32Cube HAL API that can be used
to build any firmware application to execute application stored on NOR Flash (Sub-project Appli). It boots
from internal Flash, copies the application from the external NOR Flash to the external PSRAM and jumps to
the application code in external PSRAM (Sub-project Boot).
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="Template_XIP">Template_XIP</p></td>
        <td align=left>
- This project provides a reference template based on the STM32Cube HAL API that can be used
to build any firmware application to execute from external Flash (Sub-project Appli). It boots from internal Flash
and jumps to the application code in external Flash (Sub-project Boot).
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="Template_ROT">Template_ROT</p></td>
        <td align=left><p id="OEMiROT_Appli">OEMiROT_Appli</p></td>
        <td align=left>
This project provides a OEMiROT boot path application example. Boot is performed through OEMiROT bootpath after authenticity and integrity checks of the project firmware image.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="STiROT_Appli">STiROT_Appli</p></td>
        <td align=left>
This project provides a STiROT boot path reference template. Boot is performed through STiROT boot path after authenticity and integrity checks of the project firmware image.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of templates: 8</b></td>
        <td>5</td>
        <td>0</td>
        <td>3</td>
      </tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=2><p id="Templates_Board">Templates_Board</p></td>
        <td align=left rowspan=1><p id="-">-</p></td>
        <td align=left><p id="-">-</p></td>
        <td align=left>
This project provides a reference template for the NUCLEO-H7S3L8 board based on the STM32Cube HAL API and the
BSP drivers that can be used to build any firmware application to execute from external Flash (Sub-project Appli),
It boots from internal Flash and jumps to the application code in external Flash (Sub-project Boot).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of templates_board: 1</b></td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
      </tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=2><p id="Templates_LL">Templates_LL</p></td>
        <td align=left rowspan=1><p id="-">-</p></td>
        <td align=left><p id="Starter project">Starter project</p></td>
        <td align=left>
- This project provides a reference template through the LL API that can be used
to build any firmware application.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of templates_ll: 2</b></td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
      </tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=159><p id="Examples">Examples</p></td>
        <td align=left rowspan=1><p id="-">-</p></td>
        <td align=left><p id="BSP">BSP</p></td>
        <td align=left>
- This example provides a description of how to use the different BSP drivers.
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="ADC">ADC</p></td>
        <td align=left><p id="ADC_DifferentialMode">ADC_DifferentialMode</p></td>
        <td align=left>
This example describes how to configure and use the ADC1 to convert an external
analog input in Differential Mode, difference between external voltage on VinN and VinP.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_DiscontinuousConversion_TriggerSW">ADC_DiscontinuousConversion_TriggerSW</p></td>
        <td align=left>
This example describes how to use an ADC peripheral to perform multiple conversion from different ADC channel,
one at a time after each software trigger.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_SingleConversion_TriggerSW">ADC_SingleConversion_TriggerSW</p></td>
        <td align=left>
This example describes how to use ADC to convert a single channel at each SW start, 
conversion performed using programming model: polling.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_SingleConversion_TriggerSW_HPDMA">ADC_SingleConversion_TriggerSW_HPDMA</p></td>
        <td align=left>
This example describes how to use an ADC peripheral to perform a single ADC conversion on a channel 
at each software start. Converted data is transferred by HPDMA into a table in SRAM memory.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_SingleConversion_TriggerSW_IT">ADC_SingleConversion_TriggerSW_IT</p></td>
        <td align=left>
How to use ADC to convert a single channel at each SW start,
conversion performed using programming model: interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="CORDIC">CORDIC</p></td>
        <td align=left><p id="CORDIC_Exp_DMA">CORDIC_Exp_DMA</p></td>
        <td align=left>
How to use the CORDIC peripheral to calculate the Exponential of a value.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="CORDIC_Ln_DMA">CORDIC_Ln_DMA</p></td>
        <td align=left>
How to use the CORDIC peripheral to calculate the Natural Logarithm of a value.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="CORDIC_Phase_DMA">CORDIC_Phase_DMA</p></td>
        <td align=left>
How to use the CORDIC peripheral to calculate array of Phase in DMA mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="CORDIC_Sin_DMA">CORDIC_Sin_DMA</p></td>
        <td align=left>
How to use the CORDIC peripheral to calculate array of sines in DMA mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="CORDIC_Sqrt_DMA">CORDIC_Sqrt_DMA</p></td>
        <td align=left>
How to use the CORDIC peripheral to calculate array of SQRT in DMA mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="CORTEX">CORTEX</p></td>
        <td align=left><p id="CORTEXM_CACHE">CORTEXM_CACHE</p></td>
        <td align=left>
This project provides a CORTEXM cache example based on the CMSIS API that can be used
to build any firmware application to execute from internal Flash.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="CORTEXM_MPU">CORTEXM_MPU</p></td>
        <td align=left>
Presentation of the MPU features. This example configures MPU attributes of different
MPU regions then configures a memory area as privileged read-only, and attempts to
perform read and write operations in different modes.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="CORTEXM_ModePrivilege">CORTEXM_ModePrivilege</p></td>
        <td align=left>
How to modify the Thread mode privilege access and stack. Thread mode is entered
on reset or when returning from an exception.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="CORTEXM_SysTick">CORTEXM_SysTick</p></td>
        <td align=left>
How to use the default SysTick configuration with a 1 ms timebase to toggle LEDs.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=3><p id="CRC">CRC</p></td>
        <td align=left><p id="CRC_Bytes_Stream_7bit_CRC">CRC_Bytes_Stream_7bit_CRC</p></td>
        <td align=left>
How to configure the CRC using the HAL API. The CRC (cyclic
redundancy check) calculation unit computes 7-bit CRC codes derived from buffers
of 8-bit data (bytes). The user-defined generating polynomial is manually set
to 0x65, that is, X^7 + X^6 + X^5 + X^2 + 1, as used in the Train Communication
Network, IEC 60870-5[17].
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRC_Example">CRC_Example</p></td>
        <td align=left>
How to configure the CRC using the HAL API. The CRC (cyclic
redundancy check) calculation unit computes the CRC code of a given buffer of
32-bit data words, using a fixed generator polynomial (0x4C11DB7).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRC_UserDefinedPolynomial">CRC_UserDefinedPolynomial</p></td>
        <td align=left>
How to configure the CRC using the HAL API. The CRC (cyclic
redundancy check) calculation unit computes the 8-bit CRC code for a given
buffer of 32-bit data words, based on a user-defined generating polynomial.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="CRYP">CRYP</p></td>
        <td align=left><p id="CRYP_SAES_ECB_CBC">CRYP_SAES_ECB_CBC</p></td>
        <td align=left>
How to use the Secure AES co-processor (SAES) peripheral to encrypt and decrypt data
using AES ECB and CBC algorithms.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRYP_SAES_GCM">CRYP_SAES_GCM</p></td>
        <td align=left>
This project describes how to use the CRYPTO peripheral to encrypt and decrypt data using AES with
Galois/Counter mode (GCM). It boots from internal Flash and jumps
to the application code in external Flash (Sub-project Boot).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRYP_SAES_SharedKey">CRYP_SAES_SharedKey</p></td>
        <td align=left>
How to use the Secure AES co-processor (SAES) peripheral to share application keys
with CRYP peripheral.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRYP_SAES_WrapKey">CRYP_SAES_WrapKey</p></td>
        <td align=left>  
How to use the Secure AES co-processor (SAES) peripheral to wrap application keys
using hardware secret key DHUK then use it to encrypt in polling mode.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=3><p id="DCMIPP">DCMIPP</p></td>
        <td align=left><p id="DCMIPP_ContinuousDBM">DCMIPP_ContinuousDBM</p></td>
        <td align=left>
- This example shows how to use the DCMIPP IP in continuous Double buffering Mode and it is based on the STM32Cube HAL API.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DCMIPP_ContinuousMode">DCMIPP_ContinuousMode</p></td>
        <td align=left>
- This example shows how to use the DCMIPP IP in continuous Mode and it is based on the STM32Cube HAL API.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DCMIPP_JPEGSnapshotMode">DCMIPP_JPEGSnapshotMode</p></td>
        <td align=left>
- This example shows how to use the DCMIPP IP in Snapshot and JPEG Mode and it is based on the STM32Cube HAL API.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="DMA">DMA</p></td>
        <td align=left><p id="DMA_DataHandling">DMA_DataHandling</p></td>
        <td align=left>
This example describes how to use the DMA Controller to do data handling between transferred data from the source
and transfer to the destination through the HAL API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="DMA_FLASHToRAM">DMA_FLASHToRAM</p></td>
        <td align=left>
This example describes how to use DMA to transfer a word data buffer from Flash memory to embedded
SRAM through the HAL API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="DMA_LinkedList">DMA_LinkedList</p></td>
        <td align=left>
This example describes how to use the DMA to perform a list of transfers. The transfer list is organized as linked-list,
each time the current transfer ends the DMA automatically reload the next transfer parameters, and starts it (without CPU intervention).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="DMA_RepeatedBlock">DMA_RepeatedBlock</p></td>
        <td align=left>
How to configure and use the DMA HAL API to perform repeated block transactions.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="DMA2D">DMA2D</p></td>
        <td align=left><p id="DMA2D_BlendingWithAlphaInversion">DMA2D_BlendingWithAlphaInversion</p></td>
        <td align=left>
- This example provides a description of how to configure DMA2D peripheral in Memory_to_Memory with blending transfer and alpha inversion mode. It boots from internal Flash and jumps
to the application code in external Flash.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DMA2D_MemToMemWithBlending">DMA2D_MemToMemWithBlending</p></td>
        <td align=left>
This example provides a description of how to configure DMA2D peripheral in 
  Memory_to_Memory with blending transfer mode.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DMA2D_MemToMemWithBlendingAndCLUT">DMA2D_MemToMemWithBlendingAndCLUT</p></td>
        <td align=left>
This example provides a description of how to configure DMA2D peripheral in 
Memory_to_Memory blending transfer mode with indexed 256 color images (L8).
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DMA2D_MemoryToMemory">DMA2D_MemoryToMemory</p></td>
        <td align=left>
- This example provides a description of how to configure DMA2D peripheral in Memory_to_Memory transfer mode.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DMA2D_RegToMemWithLCD">DMA2D_RegToMemWithLCD</p></td>
        <td align=left>
- This example provides a description of how to configure DMA2D peripheral in 
  Register_to_Memory transfer mode and display the result on LCD.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="DTS">DTS</p></td>
        <td align=left><p id="DTS_GetTemperature">DTS_GetTemperature</p></td>
        <td align=left>
How to configure and use the DTS to get the temperature of the die.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=7><p id="FDCAN">FDCAN</p></td>
        <td align=left><p id="FDCAN_Adaptive_Bitrate_Receiver">FDCAN_Adaptive_Bitrate_Receiver</p></td>
        <td align=left>
This example describes how to configure the FDCAN peripheral to adapt to different CAN bit rates using restricted mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FDCAN_Adaptive_Bitrate_Transmitter">FDCAN_Adaptive_Bitrate_Transmitter</p></td>
        <td align=left>
This example describes how to configure the FDCAN peripheral to adapt to different CAN bit rates using restricted mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FDCAN_Classic_Frame_Networking">FDCAN_Classic_Frame_Networking</p></td>
        <td align=left>
This example describes how to configure the FDCAN peripheral to send and receive Classic CAN frames between two FDCAN units.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FDCAN_Com_IT">FDCAN_Com_IT</p></td>
        <td align=left>
This example describes how to configure the FDCAN peripheral to achieve interrupt process communication between two FDCAN units.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FDCAN_Com_Polling">FDCAN_Com_Polling</p></td>
        <td align=left>
This example describes how to configure the FDCAN peripheral to achieve polling process communication between two FDCAN units.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FDCAN_Loopback">FDCAN_Loopback</p></td>
        <td align=left>
This example describes how to configure the FDCAN peripheral to  operate in loopback mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FDCAN_Power_Down">FDCAN_Power_Down</p></td>
        <td align=left>
This example describes the functionality of the power down mode in the FDCAN peripheral.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=3><p id="FLASH">FLASH</p></td>
        <td align=left><p id="FLASH_ECC_Error_Generation">FLASH_ECC_Error_Generation</p></td>
        <td align=left>
How to use the FLASH HAL API to manage ECC errors.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FLASH_EraseProgram">FLASH_EraseProgram</p></td>
        <td align=left>
How to configure and use the FLASH HAL API to erase and program the internal

At the beginning of the main program the HAL_Init() function is called to reset
all the peripherals, initialize the Flash interface and the systick.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FLASH_OBK_Program">FLASH_OBK_Program</p></td>
        <td align=left>
How to use the FLASH HAL API to program option bytes keys


After Reset, the Flash memory controller and option bytes access are locked. Dedicated functions
are used to enable the FLASH controller's register and option bytes access.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=3><p id="FMC">FMC</p></td>
        <td align=left><p id="FMC_NOR">FMC_NOR</p></td>
        <td align=left>
- This project is targeted to run on STM32H7S7xx device on STM32H7RS_CUSTOM_HW board from STMicroelectronics.
</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FMC_SDRAM">FMC_SDRAM</p></td>
        <td align=left>
- This project is targeted to run on STM32H7S7xx device on STM32H7RS_CUSTOM_HW board from STMicroelectronics.
</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FMC_SRAM">FMC_SRAM</p></td>
        <td align=left>
- This project is targeted to run on STM32H7S7xx device on STM32H7RS_CUSTOM_HW board from STMicroelectronics.
</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="GFXTIM">GFXTIM</p></td>
        <td align=left><p id="GFXTIM_AbsoluteTimer_FrameCount">GFXTIM_AbsoluteTimer_FrameCount</p></td>
        <td align=left>
- This example demonstrates the use of the GFXTIM peripheral to generate interrupts for specific absolute frames. It boots from internal Flash and jumps
to the application code in external Flash.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="GFXTIM_AbsoluteTimer_LineCount">GFXTIM_AbsoluteTimer_LineCount</p></td>
        <td align=left>
- This example demonstrates the use of the GFXTIM peripheral to generate interrupts for specific absolute lines. It boots from internal Flash and jumps
to the application code in external Flash.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="GFXTIM_EventGenarator_DisplayUpdate">GFXTIM_EventGenarator_DisplayUpdate</p></td>
        <td align=left>
- This example demonstrates the use of the GFXTIM peripheral to generate a complex event and update the LTDC buffer accordingly using the DMA2D. It boots from internal Flash and jumps
to the application code in external Flash.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="GFXTIM_RelativeTimer_FrameCount">GFXTIM_RelativeTimer_FrameCount</p></td>
        <td align=left>
- This example demonstrates the use of the GFXTIM peripheral to generate interrupts for specific relative frames. It boots from internal Flash and jumps
to the application code in external Flash.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="GFXTIM_Watchdog_Alarm_PreAlarm">GFXTIM_Watchdog_Alarm_PreAlarm</p></td>
        <td align=left>
- This example demonstrates the use of the GFXTIM peripheral to generate interrupts on Alarm and PreAlarm events. It boots from internal Flash and jumps
to the application code in external Flash.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="GPIO">GPIO</p></td>
        <td align=left><p id="GPIO_EXTI">GPIO_EXTI</p></td>
        <td align=left>
How to configure external interrupt lines.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="GPIO_IOToggle">GPIO_IOToggle</p></td>
        <td align=left>
How to configure and use GPIOs through the HAL API.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="HAL">HAL</p></td>
        <td align=left><p id="HAL_TimeBase_TIM">HAL_TimeBase_TIM</p></td>
        <td align=left>
How to customize HAL using a general-purpose timer as main source of time base 
instead of Systick.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=3><p id="HASH">HASH</p></td>
        <td align=left><p id="HASH_SHA256">HASH_SHA256</p></td>
        <td align=left>
- This project describes how to use the HASH peripheral to hash data
using SHA_256 Algorithm.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="HASH_SHA384">HASH_SHA384</p></td>
        <td align=left>
- This project describes how to use the HASH peripheral to hash data
using SHA_384 Algorithm.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="HASH_SHA512">HASH_SHA512</p></td>
        <td align=left>
- This project describes how to use the HASH peripheral to hash data
using SHA_512 Algorithm.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=6><p id="I2C">I2C</p></td>
        <td align=left><p id="I2C_TwoBoards_AdvComIT">I2C_TwoBoards_AdvComIT</p></td>
        <td align=left>
How to handle several I2C data buffer transmission/reception between
a master and a slave device, using an interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_ComDMA">I2C_TwoBoards_ComDMA</p></td>
        <td align=left>
How to handle I2C data buffer transmission/reception between two boards, 
via DMA.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_ComIT">I2C_TwoBoards_ComIT</p></td>
        <td align=left>
How to handle I2C data buffer transmission/reception between two boards,
using an interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_ComPolling">I2C_TwoBoards_ComPolling</p></td>
        <td align=left>
How to handle I2C data buffer transmission/reception between two boards,
in polling mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_RestartAdvComIT">I2C_TwoBoards_RestartAdvComIT</p></td>
        <td align=left>
How to perform multiple I2C data buffer transmission/reception between two boards, 
in interrupt mode and with restart condition.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_RestartComIT">I2C_TwoBoards_RestartComIT</p></td>
        <td align=left>
How to handle single I2C data buffer transmission/reception between two boards,
in interrupt mode and with restart condition.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=18><p id="I3C">I3C</p></td>
        <td align=left><p id="I3C_Controller_Direct_Command_DMA">I3C_Controller_Direct_Command_DMA</p></td>
        <td align=left>
How to handle a Direct Command procedure between an I3C Controller and an I3C Target,
using DMA.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Controller_ENTDAA_IT">I3C_Controller_ENTDAA_IT</p></td>
        <td align=left>
How to handle an ENTDAA procedure between an I3C Controller and one or more I3C Targets.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Controller_HotJoin_IT">I3C_Controller_HotJoin_IT</p></td>
        <td align=left>How to handle a HOTJOIN procedure between an I3C Controller and I3C Targets.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Controller_I2C_ComDMA">I3C_Controller_I2C_ComDMA</p></td>
        <td align=left>
How to handle I2C communication as I3C Controller data buffer transmission/reception between two boards, using DMA.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Controller_IBI_Wakeup_IT">I3C_Controller_IBI_Wakeup_IT</p></td>
        <td align=left>How to handle an In-Band-Interrupt event between an I3C Controller in Low Power Mode and I3C Targets.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Controller_InBandInterrupt_IT">I3C_Controller_InBandInterrupt_IT</p></td>
        <td align=left>How to handle an In-Band-Interrupt event between an I3C Controller and I3C Targets.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Controller_Private_Command_IT">I3C_Controller_Private_Command_IT</p></td>
        <td align=left>
How to handle I3C as Controller data buffer transmission/reception between two boards, using interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Controller_Switch_To_Target">I3C_Controller_Switch_To_Target</p></td>
        <td align=left>
How to handle a Controller Role Request Direct Command procedure between an I3C Controller and an I3C Target,
using Interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Sensor_Direct_Command_DMA">I3C_Sensor_Direct_Command_DMA</p></td>
        <td align=left>
How to handle a Direct Command procedure between STM32H7RSxx Nucleo and X-NUCLEO-IKS01A3,
using DMA.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Sensor_Private_Command_IT">I3C_Sensor_Private_Command_IT</p></td>
        <td align=left>
How to handle I3C as Controller data buffer transmission/reception between STM32H7RSxx Nucleo and X-NUCLEO-IKS01A3,
using interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Target_Direct_Command_DMA">I3C_Target_Direct_Command_DMA</p></td>
        <td align=left>
How to handle a Direct Command procedure between an I3C Controller and an I3C Target,
using Controller in DMA.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Target_ENTDAA_IT">I3C_Target_ENTDAA_IT</p></td>
        <td align=left>
How to handle an ENTDAA procedure between an I3C Controller and one or more I3C Targets.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Target_HotJoin_IT">I3C_Target_HotJoin_IT</p></td>
        <td align=left>How to handle a HOTJOIN procedure to an I3C Controller.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Target_I2C_ComDMA">I3C_Target_I2C_ComDMA</p></td>
        <td align=left>
How to handle I2C data buffer transmission/reception between two boards, using DMA.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Target_IBI_Wakeup_IT">I3C_Target_IBI_Wakeup_IT</p></td>
        <td align=left>How to handle a In Band Interrupt procedure to an I3C Controller in Stop Mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Target_InBandInterrupt_IT">I3C_Target_InBandInterrupt_IT</p></td>
        <td align=left>How to handle an In-Band-Interrupt event to an I3C Controller.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Target_Private_Command_IT">I3C_Target_Private_Command_IT</p></td>
        <td align=left>
How to handle I3C as Target data buffer transmission/reception between two boards, using interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Target_Switch_To_Controller">I3C_Target_Switch_To_Controller</p></td>
        <td align=left>How to handle a Controller Role Request procedure to an I3C Controller.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="IWDG">IWDG</p></td>
        <td align=left><p id="IWDG_Reset">IWDG_Reset</p></td>
        <td align=left>
How to handle the IWDG reload counter and simulate a software fault that generates
an MCU IWDG reset after a preset laps of time.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="IWDG_WindowMode">IWDG_WindowMode</p></td>
        <td align=left>
How to periodically update the IWDG reload counter and simulate a software fault that generates
an MCU IWDG reset after a preset laps of time.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="JPEG">JPEG</p></td>
        <td align=left><p id="JPEG_DecodingFromXSPI_DMA">JPEG_DecodingFromXSPI_DMA</p></td>
        <td align=left>
- This example demonstrates how to decode a JPEG image stored in the external FLASH (XPI2) using the JPEG HW decoder in DMA mode. The decoded image is stored in the internal SRAM.  
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="JPEG_EncodingFromXSPI_DMA">JPEG_EncodingFromXSPI_DMA</p></td>
        <td align=left>
- This example demonstrates how to encode an RGB image stored in the external FLASH (XSPI2) using the JPEG HW encoder in DMA mode and save it in the internal FLASH.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="LPTIM">LPTIM</p></td>
        <td align=left><p id="LPTIM_PWM_LSE">LPTIM_PWM_LSE</p></td>
        <td align=left>
How to configure and use, through the HAL LPTIM API, the LPTIM peripheral using LSE 
as counter clock, to generate a PWM signal, in a low-power mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="LTDC">LTDC</p></td>
        <td align=left><p id="LTDC_Display_2Layers">LTDC_Display_2Layers</p></td>
        <td align=left>
This example describes how to configure the LTDC peripheral to display two Layers  
at the same time.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="MCE">MCE</p></td>
        <td align=left><p id="MCE_AESEncryptDecryptData">MCE_AESEncryptDecryptData</p></td>
        <td align=left>
This project provides a description of how encrypt and decrypt data from external memory (PSRAM). 
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="MCE_ExecuteAESCryptedCode">MCE_ExecuteAESCryptedCode</p></td>
        <td align=left>
- This project provides a description of how to run encrypted application code from external flash. The decryption is performed on the fly using the MCE IP(AES encryption algorithm). 
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="MCE_ExecuteNoekeonCryptedCode">MCE_ExecuteNoekeonCryptedCode</p></td>
        <td align=left>
- This project provides a description of how to run encrypted application code from external flash (0x70000000-0x7FFFFFFF). The decryption is performed on the fly using the MCE IP(Noekeon encryption algorithm). 
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="MCE_NoekeonEncryptDecryptData">MCE_NoekeonEncryptDecryptData</p></td>
        <td align=left>
This project provides a description of how to encrypt and decrypt data from external memory (NOR).
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="MDF">MDF</p></td>
        <td align=left><p id="ADF_AudioSoundDetector">ADF_AudioSoundDetector</p></td>
        <td align=left>
How to use the MDF HAL API (ADF instance) to use audio sound activity detection.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="PKA">PKA</p></td>
        <td align=left><p id="PKA_ECCDoubleBaseLadder">PKA_ECCDoubleBaseLadder</p></td>
        <td align=left>
How to use the PKA to run ECC Double Base Ladder operation.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PKA_ECCProjective2Affine">PKA_ECCProjective2Affine</p></td>
        <td align=left>
How to use the PKA to run ECC Projective to Affine operation

This project runs from the external Flash memory. It is launched from a first boot stage and inherits from this boot project
configuration (caches, MPU regions [region 0 and 1], system clock at 600 MHz and external memory interface at the highest speed).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PKA_ECDSA_Sign">PKA_ECDSA_Sign</p></td>
        <td align=left>
How to compute a signed message regarding the Elliptic curve digital signature algorithm
(ECDSA).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PKA_ModExpProtected_IT">PKA_ModExpProtected_IT</p></td>
        <td align=left>How to use the PKA to run Protected modular exponentiation operation

This project is targeted to run on STM32H7S3L8Hx devices on NUCLEO-H7S3L8 board from STMicroelectronics.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=10><p id="PSSI">PSSI</p></td>
        <td align=left><p id="PSSI_Master_Com">PSSI_Master_Com</p></td>
        <td align=left>How to handle a communication procedure using two boards with PSSI.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PSSI_Master_ComDMA">PSSI_Master_ComDMA</p></td>
        <td align=left>How to handle a DMA communication procedure using two boards with PSSI.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PSSI_Master_Single_Com">PSSI_Master_Single_Com</p></td>
        <td align=left>How to handle a single communication procedure using two boards with PSSI in polling mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PSSI_Master_Single_ComDMA">PSSI_Master_Single_ComDMA</p></td>
        <td align=left>How to handle a single DMA communication procedure using two boards with PSSI.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PSSI_Slave_Com">PSSI_Slave_Com</p></td>
        <td align=left>How to handle a communication procedure using two boards with PSSI.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PSSI_Slave_ComDMA">PSSI_Slave_ComDMA</p></td>
        <td align=left>How to handle a DMA communication procedure using two boards with PSSI.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PSSI_Slave_Single_Com">PSSI_Slave_Single_Com</p></td>
        <td align=left>How to handle a single communication procedure using two boards with PSSI in polling mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PSSI_Slave_Single_ComDMA">PSSI_Slave_Single_ComDMA</p></td>
        <td align=left>How to handle a single DMA communication procedure using two boards with PSSI.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PSSI_Transmit">PSSI_Transmit</p></td>
        <td align=left>How to handle a simple Transmit procedure with PSSI.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PSSI_Transmit_DMA">PSSI_Transmit_DMA</p></td>
        <td align=left>How to handle a DMA Transmit procedure with PSSI.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="PWR">PWR</p></td>
        <td align=left><p id="PWR_SLEEP">PWR_SLEEP</p></td>
        <td align=left>
How to enter the Sleep mode and wake up from this mode by using an interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_STANDBY">PWR_STANDBY</p></td>
        <td align=left>
How to enter the Standby mode and wake up from this mode by using an external
reset or the WKUP pin.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_STANDBY_RTC">PWR_STANDBY_RTC</p></td>
        <td align=left>
How to enter the Standby mode and wake-up from this mode by using an external
reset or the RTC wakeup timer.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_STOP">PWR_STOP</p></td>
        <td align=left>
How to enter the Stop mode and wake-up from this mode by using an interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_STOP_RTC">PWR_STOP_RTC</p></td>
        <td align=left>
How to enter the Stop mode and wake-up from this mode by using an external
reset or the RTC wakeup timer.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="RAMECC">RAMECC</p></td>
        <td align=left><p id="RAMECC_ErrorCount">RAMECC_ErrorCount</p></td>
        <td align=left>
How to configure and use the RAMECC HAL API to manage ECC errors via RAMECC peripheral.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="RCC">RCC</p></td>
        <td align=left><p id="RCC_CRS_Synchronization_IT">RCC_CRS_Synchronization_IT</p></td>
        <td align=left>
Configuration of the clock recovery system (CRS) in Interrupt mode, using the RCC HAL API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RCC_CRS_Synchronization_Polling">RCC_CRS_Synchronization_Polling</p></td>
        <td align=left>
Configuration of the clock recovery system (CRS) in Polling mode, using the RCC HAL API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RCC_ClockConfig">RCC_ClockConfig</p></td>
        <td align=left>
Configuration of the system clock (SYSCLK) and modification of the clock settings in Run mode, using the RCC HAL API.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RCC_LSEConfig">RCC_LSEConfig</p></td>
        <td align=left>
Enabling/disabling of the low-speed external(LSE) RC oscillator (about 32 KHz) at run time, using the RCC HAL API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RCC_LSIConfig">RCC_LSIConfig</p></td>
        <td align=left>
How to enable/disable the low-speed internal (LSI) RC oscillator (about 32 KHz) at run time, using the RCC HAL API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="RNG">RNG</p></td>
        <td align=left><p id="RNG_MultiRNG">RNG_MultiRNG</p></td>
        <td align=left>
Configuration of the RNG using the HAL API. This example uses the RNG to generate 32-bit long random numbers.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RNG_MultiRNG_IT">RNG_MultiRNG_IT</p></td>
        <td align=left>
Configuration of the RNG using the HAL API. This example uses RNG interrupts to generate 32-bit long random numbers.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=6><p id="RTC">RTC</p></td>
        <td align=left><p id="RTC_ActiveTamper">RTC_ActiveTamper</p></td>
        <td align=left>
Configuration of the active tamper detection with backup registers erase.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_Alarm">RTC_Alarm</p></td>
        <td align=left>
Configuration and generation of an RTC alarm using the RTC HAL API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_Calendar">RTC_Calendar</p></td>
        <td align=left>
Configuration of the calendar using the RTC HAL API.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_LowPower_STANDBY_WUT">RTC_LowPower_STANDBY_WUT</p></td>
        <td align=left>
How to periodically enter and wake up from STANDBY mode thanks to the RTC Wake-Up Timer (WUT).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_Tamper">RTC_Tamper</p></td>
        <td align=left>
Configuration of the tamper detection with backup registers erase.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_TimeStamp">RTC_TimeStamp</p></td>
        <td align=left>
Configuration of the RTC HAL API to demonstrate the timestamp feature.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="SD">SD</p></td>
        <td align=left><p id="SD_ReadWrite_DMA">SD_ReadWrite_DMA</p></td>
        <td align=left>
This example performs some write and read transfers to SD Card with SDMMC IP internal DMA mode.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="SMBUS">SMBUS</p></td>
        <td align=left><p id="SMBUS_TwoBoards_ComIT_Master">SMBUS_TwoBoards_ComIT_Master</p></td>
        <td align=left> 
How to handle SMBUS data buffer transmission/reception between two boards,
in interrupt mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="SMBUS_TwoBoards_ComIT_Slave">SMBUS_TwoBoards_ComIT_Slave</p></td>
        <td align=left>
How to handle SMBUS data buffer transmission/reception between two boards,
in interrupt mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="SPDIFRX">SPDIFRX</p></td>
        <td align=left><p id="SPDIFRX_Loopback">SPDIFRX_Loopback</p></td>
        <td align=left>
How to configure and use the SPDIFRX peripheral to receive data flaw.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=8><p id="SPI">SPI</p></td>
        <td align=left><p id="SPI_ACCEL_ComPolling">SPI_ACCEL_ComPolling</p></td>
        <td align=left>
This example describes how to perform SPI transmission/reception in Polling mode
to program an Accelerometer. This examples can uses different SPI Accelerometer
from STMicroelectronics.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_EEPROM_ComPolling">SPI_EEPROM_ComPolling</p></td>
        <td align=left>
This example describes how to perform SPI data buffer transmission/reception in
Polling mode. The communication uses an SPI EEPROM memory.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_FullDuplex_ComDMA_Master">SPI_FullDuplex_ComDMA_Master</p></td>
        <td align=left>
Data buffer transmission/reception between two boards via SPI using DMA.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_FullDuplex_ComDMA_Slave">SPI_FullDuplex_ComDMA_Slave</p></td>
        <td align=left>
Data buffer transmission/reception between two boards via SPI using DMA.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_FullDuplex_ComIT_Master">SPI_FullDuplex_ComIT_Master</p></td>
        <td align=left>
Data buffer transmission/reception between two boards via SPI using Interrupt mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_FullDuplex_ComIT_Slave">SPI_FullDuplex_ComIT_Slave</p></td>
        <td align=left>
Data buffer transmission/reception between two boards via SPI using Interrupt mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_FullDuplex_ComPolling_Master">SPI_FullDuplex_ComPolling_Master</p></td>
        <td align=left>
Data buffer transmission/reception between two boards via SPI using Polling mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_FullDuplex_ComPolling_Slave">SPI_FullDuplex_ComPolling_Slave</p></td>
        <td align=left>
Data buffer transmission/reception between two boards via SPI using Polling mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=6><p id="TIM">TIM</p></td>
        <td align=left><p id="TIM_InputCapture_DMA">TIM_InputCapture_DMA</p></td>
        <td align=left>
This example demonstrates how to measure the LSI clock frequency thanks to the DMA interface of the TIM15 timer instance.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_OCActive">TIM_OCActive</p></td>
        <td align=left>
Configuration of the TIM peripheral in Output Compare Active mode 
(when the counter matches the capture/compare register, the corresponding output 
pin is set to its active state).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_OCInactive">TIM_OCInactive</p></td>
        <td align=left>
Configuration of the TIM peripheral in Output Compare Inactive mode 
with the corresponding Interrupt requests for each channel.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_OCToggle">TIM_OCToggle</p></td>
        <td align=left>
Configuration of the TIM peripheral to generate four different 
signals at four different frequencies.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_PWMInput">TIM_PWMInput</p></td>
        <td align=left>
How to use the TIM peripheral to measure the frequency and 
duty cycle of an external signal.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_PWMOutput">TIM_PWMOutput</p></td>
        <td align=left>
This example shows how to configure the TIM peripheral in PWM (Pulse Width Modulation)
mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=6><p id="UART">UART</p></td>
        <td align=left><p id="UART_Printf">UART_Printf</p></td>
        <td align=left>
Re-routing of the C library printf function to the UART.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_TwoBoards_ComDMA">UART_TwoBoards_ComDMA</p></td>
        <td align=left>
UART transmission (transmit/receive) in DMA mode between two boards.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_TwoBoards_ComDMAlinkedlist">UART_TwoBoards_ComDMAlinkedlist</p></td>
        <td align=left>
UART transmission (transmit/receive) in DMA mode using linkedlist between two boards.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_TwoBoards_ComIT">UART_TwoBoards_ComIT</p></td>
        <td align=left>
UART transmission (transmit/receive) in Interrupt mode
between two boards.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_TwoBoards_ComPolling">UART_TwoBoards_ComPolling</p></td>
        <td align=left>
UART transmission (transmit/receive) in Polling mode 
between two boards.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_WakeUpFromStopUsingFIFO">UART_WakeUpFromStopUsingFIFO</p></td>
        <td align=left>
Configuration of an UART to wake up the MCU from Stop mode with a FIFO level
when a given stimulus is received.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="USART">USART</p></td>
        <td align=left><p id="USART_SlaveMode">USART_SlaveMode</p></td>
        <td align=left>
This example describes an USART-SPI communication (transmit/receive) between two
boards where the USART is configured as a slave.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_SlaveMode_DMA">USART_SlaveMode_DMA</p></td>
        <td align=left>
This example describes an USART-SPI communication (transmit/receive) with DMA between two
boards where the USART is configured as a slave.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="WWDG">WWDG</p></td>
        <td align=left><p id="WWDG_Example">WWDG_Example</p></td>
        <td align=left>
Configuration of the HAL API to periodically update the WWDG counter and simulate a software fault that
generates an MCU WWDG reset when a predefined time period has elapsed.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="XSPI">XSPI</p></td>
        <td align=left><p id="XSPIM_SwappedMode">XSPIM_SwappedMode</p></td>
        <td align=left>
- This project provides a description of how to configure XSPIM IO Manager peripheral and commuinicate 
with external memories in Swapped mode.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="XSPI_NOR_AutoPolling_DTR">XSPI_NOR_AutoPolling_DTR</p></td>
        <td align=left>
How to use an XSPI NOR memory in Automatic polling mode.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="XSPI_NOR_ReadWhileWrite_DTR">XSPI_NOR_ReadWhileWrite_DTR</p></td>
        <td align=left>
How to write and read data using XSPI NOR memory.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="XSPI_PSRAM_MemoryMapped">XSPI_PSRAM_MemoryMapped</p></td>
        <td align=left>
How to use an XSPI PSRAM memory in memory-mapped mode.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of examples: 162</b></td>
        <td>34</td>
        <td>3</td>
        <td>125</td>
      </tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=52><p id="Examples_LL">Examples_LL</p></td>
        <td align=left rowspan=3><p id="ADC">ADC</p></td>
        <td align=left><p id="ADC_Oversampling_Init">ADC_Oversampling_Init</p></td>
        <td align=left>
How to use an ADC peripheral with oversampling.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_SingleConversion_TriggerSW_IT_Init">ADC_SingleConversion_TriggerSW_IT_Init</p></td>
        <td align=left>
How to use ADC to convert a single channel at each SW start,
conversion performed using programming model: interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_SingleConversion_TriggerSW_Init">ADC_SingleConversion_TriggerSW_Init</p></td>
        <td align=left>
How to use ADC to convert a single channel at each SW start,
conversion performed using programming model: polling.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="CORDIC">CORDIC</p></td>
        <td align=left><p id="CORDIC_CosSin">CORDIC_CosSin</p></td>
        <td align=left>
How to use the CORDIC peripheral to calculate cosine and sine.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="CORTEX">CORTEX</p></td>
        <td align=left><p id="CORTEX_MPU">CORTEX_MPU</p></td>
        <td align=left>
Presentation of the MPU features. This example configures MPU attributes of different
MPU regions then configures a memory area as privileged read-only, and attempts to
perform read and write operations in different modes.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="CRC">CRC</p></td>
        <td align=left><p id="CRC_CalculateAndCheck">CRC_CalculateAndCheck</p></td>
        <td align=left>
How to configure the CRC calculation unit to compute a CRC code for a given data
buffer, based on a fixed generator polynomial (default value 0x4C11DB7). The
peripheral initialization is done using LL unitary service functions for
optimization purposes (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRC_UserDefinedPolynomial">CRC_UserDefinedPolynomial</p></td>
        <td align=left>
How to configure and use the CRC calculation unit to compute an 8-bit CRC code
for a given data buffer, based on a user-defined generating polynomial. The
peripheral initialization is done using LL unitary service functions for
optimization purposes (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="CRS">CRS</p></td>
        <td align=left><p id="CRS_Synchronization_IT">CRS_Synchronization_IT</p></td>
        <td align=left>
How to configure the clock recovery system in IT mode through the
STM32H7RSxx CRS LL API. The peripheral initialization uses LL unitary
service functions for optimization purposes (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRS_Synchronization_Polling">CRS_Synchronization_Polling</p></td>
        <td align=left>How to configure the clock recovery system in polling mode through the
STM32H7RSxx CRS LL API. The peripheral initialization uses LL unitary
service functions for optimization purposes (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="DMA">DMA</p></td>
        <td align=left><p id="DMA_CopyFromFlashToMemory_Init">DMA_CopyFromFlashToMemory_Init</p></td>
        <td align=left>
How to use a DMA channel to transfer a word data buffer
from Flash memory to embedded SRAM. The peripheral initialization uses LL
initialization functions to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="DMA2D">DMA2D</p></td>
        <td align=left><p id="DMA2D_MemoryToMemory">DMA2D_MemoryToMemory</p></td>
        <td align=left>
- This example provides a description of how to configure DMA2D peripheral in Memory_to_Memory transfer mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="EXTI">EXTI</p></td>
        <td align=left><p id="EXTI_ToggleLedOnIT_Init">EXTI_ToggleLedOnIT_Init</p></td>
        <td align=left>
This example describes how to configure the EXTI and use
GPIOs to toggle the user LEDs available on the board when
a user button is pressed. This example is based on the
STM32H7RSxx LL API. Peripheral initialization is done using LL
initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="GPIO">GPIO</p></td>
        <td align=left><p id="GPIO_InfiniteLedToggling_Init">GPIO_InfiniteLedToggling_Init</p></td>
        <td align=left>
How to configure and use GPIOs to toggle the on-board user LEDs
every 250 ms. This example is based on the STM32H7RSxx LL API. The peripheral
is initialized with LL initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="I2C">I2C</p></td>
        <td align=left><p id="I2C_OneBoard_Communication_IT_Init">I2C_OneBoard_Communication_IT_Init</p></td>
        <td align=left>
How to handle the reception of one data byte from an I2C slave device
by an I2C master device. Both devices operate in interrupt mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=8><p id="I3C">I3C</p></td>
        <td align=left><p id="I3C_Controller_Direct_Command_IT">I3C_Controller_Direct_Command_IT</p></td>
        <td align=left>
How to handle a Direct Command procedure between an I3C Controller and an I3C Target,
using IT.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Controller_Direct_Command_Polling">I3C_Controller_Direct_Command_Polling</p></td>
        <td align=left>
How to handle a Direct Command procedure between an I3C Controller and an I3C Target, using Polling.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Controller_Private_Command_IT">I3C_Controller_Private_Command_IT</p></td>
        <td align=left>
How to handle I3C as Controller data buffer transmission/reception between two boards, using interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Controller_WakeUpFromStop">I3C_Controller_WakeUpFromStop</p></td>
        <td align=left>
How to handle I3C as Controller data buffer transmission/reception between a Target in Stop Mode, using interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Target_Direct_Command_IT">I3C_Target_Direct_Command_IT</p></td>
        <td align=left>
How to handle a Direct Command procedure between an I3C Controller and an I3C Target,
using Controller in Interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Target_Direct_Command_Polling">I3C_Target_Direct_Command_Polling</p></td>
        <td align=left>
How to handle a Direct Command procedure between an I3C Controller and an I3C Target,
using Controller in Polling.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Target_Private_Command_IT">I3C_Target_Private_Command_IT</p></td>
        <td align=left>
How to handle I3C as Target data buffer transmission/reception between two boards, using interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="I3C_Target_WakeUpFromStop">I3C_Target_WakeUpFromStop</p></td>
        <td align=left>
How to handle I3C as Target data buffer transmission/reception between two boards, using interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="IWDG">IWDG</p></td>
        <td align=left><p id="IWDG_RefreshUntilUserEvent_Init">IWDG_RefreshUntilUserEvent_Init</p></td>
        <td align=left>
How to configure the IWDG peripheral to ensure periodical counter update and
generate an MCU IWDG reset when a USER push-button is pressed. The peripheral
is initialized with LL unitary service functions to optimize
for performance and size.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="LPTIM">LPTIM</p></td>
        <td align=left><p id="LPTIM_PulseCounter_Init">LPTIM_PulseCounter_Init</p></td>
        <td align=left>
How to use the LPTIM peripheral in counter mode to generate a PWM output signal 
and update its duty cycle. This example is based on the STM32H7RSxx
LPTIM LL API. The peripheral is initialized with LL initialization 
function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="LPUART">LPUART</p></td>
        <td align=left><p id="LPUART_WakeUpFromStop_Init">LPUART_WakeUpFromStop_Init</p></td>
        <td align=left>
Configuration of GPIO and LPUART peripherals to allow characters
received on LPUART_RX pin to wake up the MCU from low-power mode. This example is based
on the LPUART LL API. The peripheral initialization uses LL
initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="PWR">PWR</p></td>
        <td align=left><p id="PWR_EnterStopMode">PWR_EnterStopMode</p></td>
        <td align=left>
How to enter the Stop mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="RCC">RCC</p></td>
        <td align=left><p id="RCC_OutputSystemClockOnMCO">RCC_OutputSystemClockOnMCO</p></td>
        <td align=left>
Configuration of MCO pin (PA8) to output the system clock.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RCC_UseHSI_PLLasSystemClock">RCC_UseHSI_PLLasSystemClock</p></td>
        <td align=left>
Modification of the PLL parameters in run time.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="RTC">RTC</p></td>
        <td align=left><p id="RTC_Alarm_Init">RTC_Alarm_Init</p></td>
        <td align=left>
Configuration of the RTC LL API to configure and generate an alarm using the RTC peripheral. The peripheral
initialization uses the LL initialization function.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_Calendar_Init">RTC_Calendar_Init</p></td>
        <td align=left>
Configuration of the LL API to set the RTC calendar. The peripheral initialization uses LL unitary service 
functions for optimization purposes (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_ExitStandbyWithWakeUpTimer_Init">RTC_ExitStandbyWithWakeUpTimer_Init</p></td>
        <td align=left>
How to periodically enter and wake up from STANDBY mode thanks to the RTC Wakeup Timer (WUT).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_Tamper_Init">RTC_Tamper_Init</p></td>
        <td align=left>
Configuration of the Tamper using the RTC LL API. The peripheral initialization
uses LL unitary service functions for optimization purposes (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_TimeStamp_Init">RTC_TimeStamp_Init</p></td>
        <td align=left>
Configuration of the Timestamp using the RTC LL API. The peripheral initialization
uses LL unitary service functions for optimization purposes (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=3><p id="SPI">SPI</p></td>
        <td align=left><p id="SPI_OneBoard_HalfDuplex_IT_Init">SPI_OneBoard_HalfDuplex_IT_Init</p></td>
        <td align=left>
Configuration of GPIO and SPI peripherals to transmit bytes
from an SPI Master device to an SPI Slave device in Interrupt mode. This example
is based on the STM32H7RSxx SPI LL API. The peripheral initialization uses
LL unitary service functions for optimization purposes (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_TwoBoards_FullDuplex_IT_Master_Init">SPI_TwoBoards_FullDuplex_IT_Master_Init</p></td>
        <td align=left>
Data buffer transmission and reception via SPI using Interrupt mode. This
example is based on the STM32H7RSxx SPI LL API. The peripheral
initialization uses LL unitary service functions for optimization purposes (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_TwoBoards_FullDuplex_IT_Slave_Init">SPI_TwoBoards_FullDuplex_IT_Slave_Init</p></td>
        <td align=left>

Data buffer transmission and receptionvia SPI using Interrupt mode. This

example is based on the STM32H7RSxx SPI LL API. The peripheral

initialization uses LL unitary service functions for optimization purposes (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="TIM">TIM</p></td>
        <td align=left><p id="TIM_BreakAndDeadtime_Init">TIM_BreakAndDeadtime_Init</p></td>
        <td align=left>
Configuration of the TIM peripheral to
generate three center-aligned PWM and complementary PWM signals,
insert a defined deadtime value,
use the break feature,
and lock the break and dead-time configuration.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_InputCapture_Init">TIM_InputCapture_Init</p></td>
        <td align=left>
Use of the TIM peripheral to measure a periodic signal frequency
provided either by an external signal generator or by
another timer instance. This example is based on the STM32H7RSxx TIM
LL API. The peripheral initialization uses LL unitary service functions
for optimization purposes (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_OutputCompare_Init">TIM_OutputCompare_Init</p></td>
        <td align=left>
Configuration of the TIM peripheral to generate an output
waveform in different output compare modes. This example is based on the
STM32H7RSxx TIM LL API. The peripheral initialization uses
LL unitary service functions for optimization purposes (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_PWMOutput_Init">TIM_PWMOutput_Init</p></td>
        <td align=left>
Use of a timer peripheral to generate a 
PWM output signal and update the PWM duty cycle. This example is based on the 
STM32H7RSxx TIM LL API. The peripheral initialization uses 
LL initialization function to demonstrate LL Init.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_TimeBase_Init">TIM_TimeBase_Init</p></td>
        <td align=left>
Configuration of the TIM peripheral to generate a timebase. This 
example is based on the STM32H7RSxx TIM LL API. The peripheral initialization 
uses LL unitary service functions for optimization purposes (performance and size). 
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=7><p id="USART">USART</p></td>
        <td align=left><p id="USART_Com_Rx_IT_Continuous_Init">USART_Com_Rx_IT_Continuous_Init</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripheral for continuously receiving characters
from HyperTerminal (PC) in Asynchronous mode using Interrupt mode. Peripheral initialization is
done using LL unitary services functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_Com_Rx_IT_Continuous_VCP_Init">USART_Com_Rx_IT_Continuous_VCP_Init</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripheral for continuously receiving characters
from HyperTerminal (PC) in Asynchronous mode using Interrupt mode. Peripheral initialization is
done using LL unitary services functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_Com_Rx_IT_Init">USART_Com_Rx_IT_Init</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripheral for receiving characters
from HyperTerminal (PC) in Asynchronous mode using Interrupt mode. Peripheral initialization is done
using LL initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_Com_Tx_IT_Init">USART_Com_Tx_IT_Init</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripheral to send characters
asynchronously to HyperTerminal (PC) in Interrupt mode. This example is based on
STM32H7RSxx USART LL API. Peripheral initialization is done using LL unitary services
functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_Com_Tx_IT_VCP_Init">USART_Com_Tx_IT_VCP_Init</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripheral to send characters
asynchronously to HyperTerminal (PC) in Interrupt mode. This example is based on
STM32H7RSxx USART LL API. Peripheral initialization is done using LL unitary services
functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_Com_Tx_Init">USART_Com_Tx_Init</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripherals to send characters
asynchronously to an HyperTerminal (PC) in Polling mode. If the transfer could not
be completed within the allocated time, a timeout allows to exit from the sequence
with a Timeout error code. This example is based on STM32H7RSxx USART LL API. Peripheral
initialization is done using LL unitary services functions for optimization purpose
(performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_Com_Tx_VCP_Init">USART_Com_Tx_VCP_Init</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripherals to send characters
asynchronously to an HyperTerminal (PC) in Polling mode. If the transfer could not
be completed within the allocated time, a timeout allows to exit from the sequence
with a Timeout error code. This example is based on STM32H7RSxx USART LL API. Peripheral
initialization is done using LL unitary services functions for optimization purpose
(performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="UTILS">UTILS</p></td>
        <td align=left><p id="UTILS_ConfigureSystemClock">UTILS_ConfigureSystemClock</p></td>
        <td align=left>
Use of UTILS LL API to configure the system clock using PLL with HSI as source clock. 
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="UTILS_ReadDeviceInfo">UTILS_ReadDeviceInfo</p></td>
        <td align=left>
This example reads the UID, Device ID and Revision ID and saves
them into a global information buffer.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="WWDG">WWDG</p></td>
        <td align=left><p id="WWDG_RefreshUntilUserEvent_Init">WWDG_RefreshUntilUserEvent_Init</p></td>
        <td align=left>
Configuration of the WWDG to periodically update the counter and
generate an MCU WWDG reset when a user button is pressed. The peripheral initialization
uses the LL unitary service functions for optimization purposes (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of examples_ll: 51</b></td>
        <td>0</td>
        <td>0</td>
        <td>51</td>
      </tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=9><p id="Examples_MIX">Examples_MIX</p></td>
        <td align=left rowspan=1><p id="ADC">ADC</p></td>
        <td align=left><p id="ADC_SingleConversion_TriggerSW_IT">ADC_SingleConversion_TriggerSW_IT</p></td>
        <td align=left>
How to use ADC to convert a single channel at each SW start,
conversion performed using programming model: interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="DMA">DMA</p></td>
        <td align=left><p id="DMA_FLASHToRAM">DMA_FLASHToRAM</p></td>
        <td align=left>
How to use a DMA to transfer a word data buffer from Flash memory to embedded
SRAM through the STM32H7RSxx DMA HAL and LL API. The LL API is used for
performance improvement.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="PWR">PWR</p></td>
        <td align=left><p id="PWR_STOP">PWR_STOP</p></td>
        <td align=left>
How to enter the STOP mode and wake up from this mode by using external 
reset or wakeup interrupt (all the RCC function calls use RCC LL API 
for minimizing footprint and maximizing performance).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="SPI">SPI</p></td>
        <td align=left><p id="SPI_FullDuplex_ComPolling_Master">SPI_FullDuplex_ComPolling_Master</p></td>
        <td align=left>
Data buffer transmission/reception between two boards via SPI using Polling mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_FullDuplex_ComPolling_Slave">SPI_FullDuplex_ComPolling_Slave</p></td>
        <td align=left>
Data buffer transmission/reception between two boards via SPI using Polling mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="TIM">TIM</p></td>
        <td align=left><p id="TIM_PWMInput">TIM_PWMInput</p></td>
        <td align=left>
Use of the TIM peripheral to measure an external signal frequency and
duty cycle.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="UART">UART</p></td>
        <td align=left><p id="UART_HyperTerminal_IT">UART_HyperTerminal_IT</p></td>
        <td align=left>
Use of a UART to transmit data (transmit/receive)
between a board and an HyperTerminal PC application in Interrupt mode. This example
describes how to use the USART peripheral through the STM32H7RSxx UART HAL
and LL API, the LL API being used for performance improvement.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_HyperTerminal_TxPolling_RxIT">UART_HyperTerminal_TxPolling_RxIT</p></td>
        <td align=left>
Use of a UART to transmit data (transmit/receive)
between a board and an HyperTerminal PC application both in Polling and Interrupt
modes. This example describes how to use the USART peripheral through
the STM32H7RSxx UART HAL and LL API, the LL API being used for performance improvement.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of examples_mix: 8</b></td>
        <td>0</td>
        <td>0</td>
        <td>8</td>
      </tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=35><p id="Applications">Applications</p></td>
        <td align=left rowspan=1><p id="-">-</p></td>
        <td align=left><p id="OpenBootloader">OpenBootloader</p></td>
        <td align=left>
This application exploits OpenBootloader Middleware to demonstrate how to develop an IAP application
and how use it.
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=3><p id="FatFs">FatFs</p></td>
        <td align=left><p id="FatFs_MultiAccess">FatFs_MultiAccess</p></td>
        <td align=left>
This application provides a description on how to use STM32Cube firmware with FatFs
middleware component as a generic FAT file system module, in order to develop an
application exploiting FatFs offered features with microSD drive in RTOS mode
configuration.
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FatFs_uSD_RTOS">FatFs_uSD_RTOS</p></td>
        <td align=left>
This application provides a description on how to use STM32Cube firmware with FatFs
middleware component as a generic FAT file system module, in order to develop an
application exploiting FatFs offered features with microSD drive in RTOS mode
configuration.
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FatFs_uSD_Standalone">FatFs_uSD_Standalone</p></td>
        <td align=left>
How to use STM32Cube firmware with FatFs middleware component as a generic FAT
file system module. This example develops an application that exploits FatFs
features to configure a microSD drive.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="FreeRTOS">FreeRTOS</p></td>
        <td align=left><p id="FreeRTOS_MPU">FreeRTOS_MPU</p></td>
        <td align=left>
This application demonstrates the use of the MPU with FreeRTOS to control memory/peripheral access for tasks.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_Mutex">FreeRTOS_Mutex</p></td>
        <td align=left>
This application demonstrates the use of mutexes to serialize access to a shared resource.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_Queues_ThreadFlags">FreeRTOS_Queues_ThreadFlags</p></td>
        <td align=left>
This application demonstrates the use of message queues, and thread flags with CMSIS_RTOS2 API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_Semaphore_LowPower">FreeRTOS_Semaphore_LowPower</p></td>
        <td align=left>
This application demonstrates the use of FreeRTOS tickless low power mode and semaphores.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=9><p id="LwIP">LwIP</p></td>
        <td align=left><p id="LwIP_HTTP_Server_Netconn_RTOS">LwIP_HTTP_Server_Netconn_RTOS</p></td>
        <td align=left>
- This application guides STM32Cube HAL API users to run a http server application based on Netconn API of LwIP TCP/IP stack.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="LwIP_HTTP_Server_Raw">LwIP_HTTP_Server_Raw</p></td>
        <td align=left>
This application guides STM32Cube HAL API users to run a http server application based on Raw API of LwIP TCP/IP stack.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="LwIP_HTTP_Server_Socket_RTOS">LwIP_HTTP_Server_Socket_RTOS</p></td>
        <td align=left>
This application guides STM32Cube HAL API users to run a http server application based on Socket API of LwIP TCP/IP stack.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="LwIP_TCP_Echo_Client">LwIP_TCP_Echo_Client</p></td>
        <td align=left>
This application guides STM32Cube HAL API users to run TCP Echo Client application based on Raw API of LwIP TCP/IP stack.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="LwIP_TCP_Echo_Server">LwIP_TCP_Echo_Server</p></td>
        <td align=left>
This application guides STM32Cube HAL API users to run TCP Echo Server application based on Raw API of LwIP TCP/IP stack.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="LwIP_TFTP_Server">LwIP_TFTP_Server</p></td>
        <td align=left>
This application guides STM32Cube HAL API users to run a tftp server application for STM32H7S7xx devices.
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="LwIP_UDPTCP_Echo_Server_Netconn_RTOS">LwIP_UDPTCP_Echo_Server_Netconn_RTOS</p></td>
        <td align=left>
This application guides STM32Cube HAL API users to run UDP TCP Echo Server application based on Netconn API of LwIP TCP/IP stack.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="LwIP_UDP_Echo_Client">LwIP_UDP_Echo_Client</p></td>
        <td align=left>
This application guides STM32Cube HAL API users to run UDP Echo Client application based on Raw API of LwIP TCP/IP stack.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="LwIP_UDP_Echo_Server">LwIP_UDP_Echo_Server</p></td>
        <td align=left>
This application guides STM32Cube HAL API users to run UDP Echo Server application based on Raw API of LwIP TCP/IP stack.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="ROT">ROT</p></td>
        <td align=left><p id="OEMiROT_Appli">OEMiROT_Appli</p></td>
        <td align=left>
This project provides an OEMiROT boot path application example. Boot is performed through OEMiROT boot path after authenticity and integrity checks of the project firmware image.
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="OEMiROT_Boot">OEMiROT_Boot</p></td>
        <td align=left>
This project provides an OEMiROT example. OEMiROT boot path performs authenticity and integrity checks of the project firmware image.
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="STiROT_Appli">STiROT_Appli</p></td>
        <td align=left>
This project provides a STiROT boot path application example. Boot is performed through STiROT boot path after authenticity and integrity checks of the project firmware image.
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="STiROT_iLoader">STiROT_iLoader</p></td>
        <td align=left>
This project provides a STiROT boot path immutable loader example. Boot is performed through STiROT boot path after
write-protection check on the flash.
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="USBPD">USBPD</p></td>
        <td align=left><p id="USBPD_SNK">USBPD_SNK</p></td>
        <td align=left>
This application is a USBPD type C Consumer using FreeRTOS.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="USBPD_SRC">USBPD_SRC</p></td>
        <td align=left>
This application is a USBPD type C Provider using FreeRTOS.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=6><p id="USB_Device">USB_Device</p></td>
        <td align=left><p id="Audio_Standalone">Audio_Standalone</p></td>
        <td align=left>
- This application is a part of the USB Device Library package using STM32Cube firmware. It describes how to
use USB device application based on the AUDIO Class implementation of an audio streaming
(Out: Speaker/Headset) capability on the STM32H7RSxx devices.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CDC_Standalone">CDC_Standalone</p></td>
        <td align=left>
This application is a part of the USB Device Library package using STM32Cube firmware. It describes how to
use USB device application based on the Device Communication Class (CDC) following the PSTN subprotocol
in the NUCLEO-H7S3L8 devices using the OTG-USB and UART peripherals.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="Composite_CDC_HID_Standalone">Composite_CDC_HID_Standalone</p></td>
        <td align=left>
This application is a part of the USB Device Library package using STM32Cube firmware. It describes how to use USB device application based on the CDC HID composite device on the NUCLEO-H7S3L8 device.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="HID_Standalone">HID_Standalone</p></td>
        <td align=left>
This application provides an example of FreeRTOS on NUCLEO-H7S3L8 board,
it shows how to develop USB Device Human Interface HID mouse based application.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>CubeMx</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="MSC_Standalone">MSC_Standalone</p></td>
        <td align=left>
- This application is a part of the USB Device Library package using STM32Cube firmware. It describes how to
use USB device application based on the Mass Storage Class (MSC) on the STM32H7rsxx devices.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="Video_Standalone">Video_Standalone</p></td>
        <td align=left>
This application is a part of the USB Device Library package using STM32Cube firmware. It describes how to use USB device application based on the Device video Class in the NUCLEO-H7S3L8 devices using the OTG-USB peripherals.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="USB_Host">USB_Host</p></td>
        <td align=left><p id="AUDIO_Standalone">AUDIO_Standalone</p></td>
        <td align=left>
- This application is a part of the USB Host Library package using STM32Cube firmware. It describes how to
use USB Host application based on the AUDIO Class implementation of an audio streaming Wav files from sd card capability on the STM32H7RSxx Hosts.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CDC_Standalone">CDC_Standalone</p></td>
        <td align=left>
This application is a part of the USB Host Library package using STM32Cube firmware. It describes how to use
USB host application based on the Communication Class (CDC) on the stm32h7rsxx devices.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DualClass_Standalone">DualClass_Standalone</p></td>
        <td align=left>
This application is a part of the USB Host Library package using STM32Cube firmware.
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="HID_RTOS">HID_RTOS</p></td>
        <td align=left>
This application is an example implementation of a USB HID (Human Interface Device) host with FreeRTOS, supporting both high-speed (HS) and full-speed (FS) USB devices.
</td>
        <td><font size="5" color=green>CubeMx</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="MSC_RTOS">MSC_RTOS</p></td>
        <td align=left>
This application is an example implementation of a USB MSC (Mass Storage Class) host with FreeRTOS, supporting high-speed (HS).
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of applications: 36</b></td>
        <td>18</td>
        <td>0</td>
        <td>18</td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
      	<td colspan="4"><b>Total number of projects: 268</b></td>
      	<td>58</td>
      	<td>3</td>
      	<td>207</td>
      </tr>
    </table>
  </body>
</html>
